# 210413.索引切片

取一个`list`或`tuple`的部分元素是非常常见的操作  
比如，一个`list`如下：
```python
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
```
取前3个元素，有几种办法：

* 下标索引：但是扩展一下，要取前N个元素就没辙了
```python
>>> [L[0], L[1], L[2]]
['Michael', 'Sarah', 'Tracy']
```

* 循环：取前N个元素，也就是索引为`0 ~ (N-1)`的元素
```python
>>> r = []
>>> n = 3
>>> for i in range(n):
...     r.append(L[i])
... 
>>> r
['Michael', 'Sarah', 'Tracy']
```
对这种经常取指定索引范围的操作，用循环十分繁琐  
因此，Python提供了**切片（Slice）操作符**，能大大简化这种操作


## 简单切片
**简单切片指的是这样的切片形式：`a[start:stop]`**  
其行为是：得到下标在这样一个**前闭后开区间范围内**的元素  
切片的方向默认是<u>**从`start`索引开始从左往右进行切片，直到`stop`索引为止**</u>  
其中`start`和`stop`为负数时，简单看作是负数下标对应的位置即可

对应上面的问题：
```python
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
```

取前3个元素，用一行代码就可以完成切片：
```python
>>> L[0:3]
['Michael', 'Sarah', 'Tracy']
```

`L[0:3]`表示：**从索引`0`开始取，直到索引`3`为止，<u>但不包括索引`3`</u>**  
即索引`0，1，2`，正好是3个元素

如果第一个索引是`0`，还可以省略：
```python
>>> L[:3]
['Michael', 'Sarah', 'Tracy']
```

也可以从索引`1`开始，取出2个元素出来，即从索引`1 ~ 3`，但不包括索引`3`：
```python
>>> L[1:3]
['Sarah', 'Tracy']
```

类似的，既然Python支持`L[-1]`取倒数第一个元素，那么它同样支持倒数切片：
```python
# 从倒数第二个元素开始，从左往右切片
>>> L[-2:]
['Bob', 'Jack']

# 从倒数第二个元素开始，从左往右切片，到倒数第一个元素为止（但是不包含倒数第一个）
>>> L[-2:-1]
['Bob']
```
> 记住倒数第一个元素的索引是`-1`

### 超出有效索引范围
当`start`或`stop`超出一个序列的有效索引范围时  
**切片操作不会抛出异常，而是进行截断**  

> 可以这样去理解截断机制：假设把索引范围扩充到全体整数  
> 只不过**小于或大于实际索引范围的区域**对应空元素  
> 在这个扩充后的数轴上进行切片，只需把最终结果中的所有空元素忽略即可

举例：
```python
 >>> a
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

 >>> a[-100:5]
 [0, 1, 2, 3, 4]

 >>> a[5:100]
 [5, 6, 7, 8, 9]

 >>> a[-100:100]
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

 >>> a[100:1000]
 []
 ```

如果`start`的位置比`stop`还靠后，Python还是不会抛出异常，**而是直接返回空序列**：
```python
 >>> a[6:5]
 []
 ```

### 切片参数的缺省值
`start`和`stop`都是可以缺省的  
**在缺省的情况下，Python的行为是尽可能取最大区间**  

按照扩充索引范围的观点，`start`的缺省值是无穷小，`stop`的缺省值是无穷大  
但是它们都会**默认从左往右**进行切片操作
```python
 >>> a
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

 >>> a[:5]
 [0, 1, 2, 3, 4]

 >>> a[5:]
 [5, 6, 7, 8, 9]

 >>> a[100:]
 []

 # 如果什么参数也没有，那么切片的结果就是序列本身
 >>> a[:]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 扩展切片
早期的Python解释器仅支持上述`a[start:stop]`形式的基本切片  
后来加入了下面要介绍的切片形式：扩展切片

**扩展切片指的是这样的切片形式：`a[start:stop:step]`**  
其中`step`是一个非零整数，即比简单切片多了**调整步长**的功能  

拓展切片的行为是：**从`start`索引出发，以`step`为步长从左往右对序列切片，直到`stop`对应的索引为止（但不包括`stop`本身）**   

> 事实上，简单切片就是`step = 1`时扩展切片的特殊情况  

当`step`为正数时，`start`和`stop`的截断，缺省规则与简单切片完全一致：
```python
 >>> a
 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

 # 在索引0~6范围内（不包括6），步长为2，从左到右切片
 >>> a[0:6:2]
 [0, 2, 4]

 # 在全部范围内，步长为2，从左到右切片
 >>> a[::2]
 [0, 2, 4, 6, 8]

 # 从序列顶端一直到序列倒数第二个的元素（不包括自身）的范围内，步长为2，从左往右切片
 >>> a[:-2:2]
 [0, 2, 4, 6]

 # 从索引4开始到序列末尾的范围内，步长为2，从左往右切片
 >>> a[4::2]
 [4, 6, 8]
```

当`step`为负数时，切片将其解释为：从`start`出发，以步长`step`**逆序索引序列**  
也就是切片的方向变成了**从右往左**

```python
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> a[::-1]
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

>>> a[::-2]
[9, 7, 5, 3, 1]

```

此时要注意，由于切片方向发生了变化，所以`start`和`stop`的参数位置也发生了变化  
实际上，相比默认方向的表达式，**此时的切片表达式就变成了`a[stop:start:step]`**

```python
# 默认方向下，从索引0~5，步长为1，从左往右切片
>>> a[0:5:1]
[0, 1, 2, 3, 4]

# 但是在步长为负数时，索引方向发生了变化
# 下面的表达式实际的意思变成了，从索引0开始，步长为1，从右往左切片
# 因为从索引0往右走已经超出了序列范围，所以返回的结果是空序列
>>> a[0:5:-1]
[]

# 换一下索引数字的位置，现在是：从索引5开始，到索引0为止，步长为1，从右往左切片
>>> a[5:0:-1]
[5, 4, 3, 2, 1]
```

在缺省的情况下，Python的行为是尽可能取最大区间，此时访问是逆序的  
按照扩充索引范围的观点，`start`的缺省值是无穷大，`stop`的缺省值是无穷小
> 这样做才会保证切片索引的空间是最大范围

## 切片操作示例
先创建一个0-99的数列：
```python
>>> L = list(range(100))
```

可以通过切片轻松取出某一段数列，比如前10个数：
```python
>>> L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

后10个数：
```python
>>> L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
```

第11-20个数：
```python
>>> L[10:20]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
```

前10个数，每两个取一个：
```python
>>> L[:10:2]
[0, 2, 4, 6, 8]
```

所有数，每5个取一个：
```python
>>> L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
```

只写`[:]`就可以原样复制一个`list`：
```python
>>> L[:]
[0, 1, 2, 3, ..., 99]
```

`tuple`也是一种序列，唯一区别是`tuple`不可变  
因此，`tuple`也可以用切片操作，只是操作的结果仍是`tuple`：
```python
>>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
```

字符串`str`也可以看成是一种`list`，每个元素就是一个字符  
因此，字符串也可以用切片操作，只是操作结果仍是字符串：
```python
>>> 'ABCDEFG'[:3]
'ABC'
>>> 'ABCDEFG'[::2]
'ACEG'
```

